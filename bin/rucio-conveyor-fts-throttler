#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2019-2021 CERN
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Authors:
# - Dilaksun Bavarajan, <dilaksun@hotmail.com>, 2019
# - Joel Dierkes <joel.dierkes@cern.ch>, 2021

"""
Conveyor FTS Throttler is a daemon that will configure a fts storage's transfer settings
depending on how many time out errors occur at the storage. If a storage has substantial amount
of transfer failures due to time outs, it is usually due to bad connectivity and the amount of failures can be
alleviated by limiting the transfer settings of FTS transfers on the particular fts storage.
"""

import argparse
import signal

from rucio.common.utils import StoreAndDeprecateWarningAction
from rucio.daemons.conveyor.fts_throttler import run, stop


def get_parser():
    """
    Returns the argparse parser.
    """
    parser = argparse.ArgumentParser(description="The fts_throttler daemon is responsible for automatically setting\
                                     the configurations of FTS storages depending on specific transfer failures.\
                                     It does this by retrieving transfer failure information from elastic search, depending on their failure ratio.\
                                     it will use http requests to set the storage configurations accordingly")
    parser.add_argument("--run-once", action="store_true", default=False, help='One iteration only')
    parser.add_argument("--cycle_interval", "--cycle-interval", new_option_string="--cycle-interval", action=StoreAndDeprecateWarningAction, default=3600, type=int, help='interval for each cycle')

    return parser


if __name__ == '__main__':

    signal.signal(signal.SIGTERM, stop)
    parser = get_parser()
    args = parser.parse_args()
    try:
        run(once=args.run_once, cycle_interval=args.cycle_interval)
        # signal pause makes the CLI usage work for now, although doesnt work on windows.
        signal.pause()
    except KeyboardInterrupt:
        stop()
